import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

#--------------------------------------------------------------------
# ğŸ“¦ Step 1: Load the Online Retail Dataset
#--------------------------------------------------------------------

# Title of the App
st.title("ğŸ›’ Online Retail Customer Segmentation")
st.write("ğŸ” Analyzing customer purchase behavior using K-Means clustering.")

st.markdown("---")  # Separator Line

# Load Dataset
@st.cache_data
def load_data():
    url = "https://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx"
    df = pd.read_excel(url)
    return df

df = load_data()

st.subheader("ğŸ“„ Dataset Overview")
st.write("This dataset contains transactional data from a UK-based online retailer.")
st.dataframe(df.head())

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ“Š Step 2: Feature Descriptions
#--------------------------------------------------------------------
st.subheader("ğŸ” Feature Descriptions")
st.write("Understanding the key features in the dataset:")
st.write("- **ğŸ§¾ InvoiceNo**: Unique identifier for each transaction (starts with 'C' if canceled).")
st.write("- **ğŸ”¢ StockCode**: Unique product code.")
st.write("- **ğŸ“¦ Description**: Product name.")
st.write("- **ğŸ”¢ Quantity**: Number of units purchased (negative values indicate returns).")
st.write("- **ğŸ“… InvoiceDate**: Timestamp of the transaction.")
st.write("- **ğŸ’° UnitPrice**: Price per unit of the product.")
st.write("- **ğŸ†” CustomerID**: Unique identifier for each customer.")
st.write("- **ğŸŒ Country**: Customer's country of residence.")
st.write("- **ğŸ’µ TotalSales**: Total revenue generated by a customer (Quantity * UnitPrice).")
st.write("- **ğŸ“„ UniqueInvoices**: Number of unique purchases made by the customer.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ›  Step 3: Data Preprocessing
#--------------------------------------------------------------------
st.subheader("ğŸ›  Data Preprocessing")

st.write("### 1ï¸âƒ£ Drop Rows with Missing CustomerID and Description")
st.write("**Code:** `df = df.dropna(subset=['CustomerID', 'Description'])`\n\n**Purpose:** This removes any rows in the dataset where CustomerID or Description is missing (NaN values). Transactions without these values are incomplete and not useful for analysis.")
df = df.dropna(subset=['CustomerID', 'Description'])

st.markdown("---")  # Separator Line

st.write("### 2ï¸âƒ£ Remove Negative or Zero Quantities")
st.write("**Code:** `df = df[df['Quantity'] > 0]`\n\n**Purpose:** This filters out rows where the Quantity is zero or negative. Negative values may indicate returns or errors, and zero quantities are not meaningful for sales analysis. We only keep rows where the quantity is positive.")
df = df[df['Quantity'] > 0]

st.markdown("---")  # Separator Line

st.write("### 3ï¸âƒ£ Create a New Feature for Total Sales")
st.write("**Code:** `df['TotalSales'] = df['Quantity'] * df['UnitPrice']`\n\n**Purpose:** This creates a new column called TotalSales by multiplying the Quantity of items by the UnitPrice. This gives the total revenue generated for each transaction.")
df['TotalSales'] = df['Quantity'] * df['UnitPrice']

st.markdown("---")  # Separator Line

st.write("### 4ï¸âƒ£ Group by CustomerID to Get Aggregated Features for Clustering")
st.write("**Purpose:** This groups the data by CustomerID and calculates aggregate statistics for each customer:")
st.write("- `'Quantity': 'sum'` â†’ Sums the total quantity of products purchased by each customer.")
st.write("- `'TotalSales': 'sum'` â†’ Sums the total sales amount (revenue) for each customer.")
st.write("- `'InvoiceNo': 'nunique'` â†’ Counts the number of unique invoices (transactions) per customer.")
customer_df = df.groupby('CustomerID').agg({
    'Quantity': 'sum',
    'TotalSales': 'sum',
    'InvoiceNo': 'nunique'
}).reset_index()
customer_df.columns = ['CustomerID', 'TotalQuantity', 'TotalSales', 'UniqueInvoices']

# Format CustomerID as integer (remove commas)
customer_df['CustomerID'] = customer_df['CustomerID'].astype(int).astype(str)
# Format TotalSales as currency
customer_df['TotalSales'] = customer_df['TotalSales'].apply(lambda x: f"${x:,.2f}")

st.markdown("---")  # Separator Line

st.subheader("ğŸ“Š Preprocessed Data")
st.write("Aggregated features for clustering:")
st.dataframe(customer_df.head())

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ“ˆ Step 4: Elbow Method to Determine Optimal Clusters
#--------------------------------------------------------------------
scaler = StandardScaler()
X_scaled = scaler.fit_transform(customer_df[['TotalQuantity', 'UniqueInvoices']])

inertia = []
K_range = range(1, 11)
for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

st.subheader("ğŸ“ Elbow Method to Determine Optimal Clusters")
st.write("This method helps identify the optimal number of clusters by plotting inertia.")
fig, ax = plt.subplots()
ax.plot(K_range, inertia, 'bo-')
ax.set_xlabel("Number of Clusters")
ax.set_ylabel("Inertia")
ax.set_title("Elbow Method")
st.pyplot(fig)

st.write("The Elbow Method helps determine the optimal number of clusters by looking for the 'elbow' point where the inertia curve starts to flatten. The chosen number of clusters should be at this inflection point, balancing compactness and complexity.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ¯ Step 5: Customer Segments
#--------------------------------------------------------------------
st.subheader("ğŸ¯ Customer Segments")
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
customer_df['Cluster'] = kmeans.fit_predict(X_scaled)
st.write("Customers are segmented into different clusters based on purchasing behavior.")
st.dataframe(customer_df)

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸŒ Step 6: 3D Cluster Visualization
#--------------------------------------------------------------------
st.subheader("ğŸŒ 3D Cluster Visualization")
st.write("An interactive 3D scatter plot showing customer segmentation.")
fig = px.scatter_3d(customer_df, x='TotalQuantity', y='TotalSales', z='UniqueInvoices',
                    color=customer_df['Cluster'].astype(str),
                    title='K-Means Clustering (3D Visualization)',
                    labels={'TotalQuantity': 'Total Quantity', 'TotalSales': 'Total Sales', 'UniqueInvoices': 'Unique Invoices'},
                    opacity=0.7)
st.plotly_chart(fig, use_container_width=True)

st.write("### Cluster Color Legend:")
st.write("- ğŸŸ¥ **Cluster 0**: Low-value buyers, infrequent purchases.")
st.write("- ğŸŸ© **Cluster 1**: Medium-value customers, moderate purchase frequency.")
st.write("- ğŸŸ¦ **Cluster 2**: High-value customers, frequent and large purchases.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ”® Step 7: Predict Customer Segment (Sidebar)
#--------------------------------------------------------------------
st.sidebar.header("ğŸ”® Predict Customer Segment")
total_quantity = st.sidebar.slider("Total Quantity Purchased", min_value=0, max_value=5000, value=500)
total_sales = st.sidebar.slider("Total Sales Value", min_value=0.0, max_value=50000.0, value=12000.0)
unique_invoices = st.sidebar.slider("Unique Invoices", min_value=1, max_value=50, value=5)

if st.sidebar.button("ğŸ” Predict Cluster"):
    new_data_scaled = scaler.transform([[total_quantity, unique_invoices]])
    predicted_cluster = kmeans.predict(new_data_scaled)[0]
    st.sidebar.success(f"The new customer belongs to Cluster {predicted_cluster}.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ THE END
#--------------------------------------------------------------------
st.write("### ğŸ‘¨â€ğŸ« Created by Dr. Alvin Ang")

