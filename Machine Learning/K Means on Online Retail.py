import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

#--------------------------------------------------------------------
# ğŸ“¦ Step 1: Load the Online Retail Dataset
#--------------------------------------------------------------------

# Title of the App
st.title("ğŸ›’ Online Retail Customer Segmentation")
st.write("ğŸ” Analyzing customer purchase behavior using K-Means clustering.")

st.markdown("---")  # Separator Line

# Load Dataset
@st.cache_data
def load_data():
    url = "https://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx"
    df = pd.read_excel(url)
    return df

df = load_data()

st.subheader("ğŸ“„ Dataset Overview")
st.write("This dataset contains transactional data from a UK-based online retailer.")
st.dataframe(df.head())

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ“Š Step 2: Feature Descriptions
#--------------------------------------------------------------------
st.subheader("ğŸ” Feature Descriptions")
st.write("Understanding the key features in the dataset:")
st.write("- **ğŸ§¾ InvoiceNo**: Unique identifier for each transaction (starts with 'C' if canceled).")
st.write("- **ğŸ”¢ StockCode**: Unique product code.")
st.write("- **ğŸ“¦ Description**: Product name.")
st.write("- **ğŸ”¢ Quantity**: Number of units purchased (negative values indicate returns).")
st.write("- **ğŸ“… InvoiceDate**: Timestamp of the transaction.")
st.write("- **ğŸ’° UnitPrice**: Price per unit of the product.")
st.write("- **ğŸ†” CustomerID**: Unique identifier for each customer.")
st.write("- **ğŸŒ Country**: Customer's country of residence.")
st.write("- **ğŸ’µ TotalSales**: Total revenue generated by a customer (Quantity * UnitPrice).")
st.write("- **ğŸ“„ UniqueInvoices**: Number of unique purchases made by the customer.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ›  Step 3: Data Preprocessing
#--------------------------------------------------------------------
st.subheader("ğŸ›  Data Preprocessing")

st.write("### 1ï¸âƒ£ Drop Rows with Missing CustomerID and Description")
df = df.dropna(subset=['CustomerID', 'Description'])
st.write("Removed rows with missing CustomerID and Description.")

st.write("### 2ï¸âƒ£ Remove Negative or Zero Quantities")
df = df[df['Quantity'] > 0]
st.write("Filtered out transactions with negative or zero quantities.")

st.write("### 3ï¸âƒ£ Create a New Feature for Total Sales")
df['TotalSales'] = df['Quantity'] * df['UnitPrice']
st.write("Computed total revenue for each transaction.")

st.write("### 4ï¸âƒ£ Group by CustomerID to Get Aggregated Features for Clustering")
customer_df = df.groupby('CustomerID').agg({
    'Quantity': 'sum',
    'TotalSales': 'sum',
    'InvoiceNo': 'nunique'
}).reset_index()
customer_df.columns = ['CustomerID', 'TotalQuantity', 'TotalSales', 'UniqueInvoices']

# Format CustomerID as integer (remove commas)
customer_df['CustomerID'] = customer_df['CustomerID'].astype(int).astype(str)
# Format TotalSales as currency
customer_df['TotalSales'] = customer_df['TotalSales'].apply(lambda x: f"${x:,.2f}")

st.markdown("---")  # Separator Line

st.subheader("ğŸ“Š Preprocessed Data")
st.write("Aggregated features for clustering:")
st.dataframe(customer_df.head())

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ“ˆ Step 4: Elbow Method to Determine Optimal Clusters
#--------------------------------------------------------------------
scaler = StandardScaler()
X_scaled = scaler.fit_transform(customer_df[['TotalQuantity', 'UniqueInvoices']])

inertia = []
K_range = range(1, 11)
for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

st.subheader("ğŸ“ Elbow Method to Determine Optimal Clusters")
st.write("This method helps identify the optimal number of clusters by plotting inertia.")
fig, ax = plt.subplots()
ax.plot(K_range, inertia, 'bo-')
ax.set_xlabel("Number of Clusters")
ax.set_ylabel("Inertia")
ax.set_title("Elbow Method")
st.pyplot(fig)

st.write("The Elbow Method helps determine the optimal number of clusters by looking for the 'elbow' point where the inertia curve starts to flatten. The chosen number of clusters should be at this inflection point, balancing compactness and complexity.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ¯ Step 5: Customer Segments
#--------------------------------------------------------------------
st.subheader("ğŸ¯ Customer Segments")
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
customer_df['Cluster'] = kmeans.fit_predict(X_scaled)
st.write("Customers are segmented into different clusters based on purchasing behavior.")
st.dataframe(customer_df)

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸŒ Step 6: 3D Cluster Visualization
#--------------------------------------------------------------------
st.subheader("ğŸŒ 3D Cluster Visualization")
st.write("An interactive 3D scatter plot showing customer segmentation.")
fig = px.scatter_3d(customer_df, x='TotalQuantity', y='TotalSales', z='UniqueInvoices',
                    color=customer_df['Cluster'].astype(str),
                    title='K-Means Clustering (3D Visualization)',
                    labels={'TotalQuantity': 'Total Quantity', 'TotalSales': 'Total Sales', 'UniqueInvoices': 'Unique Invoices'},
                    opacity=0.7)
st.plotly_chart(fig, use_container_width=True)

st.write("### Cluster Color Legend:")
st.write("- ğŸŸ¥ **Cluster 0**: Low-value buyers, infrequent purchases.")
st.write("- ğŸŸ© **Cluster 1**: Medium-value customers, moderate purchase frequency.")
st.write("- ğŸŸ¦ **Cluster 2**: High-value customers, frequent and large purchases.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ”® Step 7: Predict Customer Segment (Sidebar)
#--------------------------------------------------------------------
st.sidebar.header("ğŸ”® Predict Customer Segment")
total_quantity = st.sidebar.slider("Total Quantity Purchased", min_value=0, max_value=5000, value=500)
total_sales = st.sidebar.slider("Total Sales Value", min_value=0.0, max_value=50000.0, value=12000.0)
unique_invoices = st.sidebar.slider("Unique Invoices", min_value=1, max_value=50, value=5)

if st.sidebar.button("ğŸ” Predict Cluster"):
    new_data_scaled = scaler.transform([[total_quantity, unique_invoices]])
    predicted_cluster = kmeans.predict(new_data_scaled)[0]
    st.sidebar.success(f"The new customer belongs to Cluster {predicted_cluster}.")

st.markdown("---")  # Separator Line

#--------------------------------------------------------------------
# ğŸ THE END
#--------------------------------------------------------------------
st.write("### ğŸ‘¨â€ğŸ« Created by Dr. Alvin Ang")

